<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>em-odp: Queues</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doc-stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">em-odp
   &#160;<span id="projectnumber">2.2.0</span>
   </div>
   <div id="projectbrief">Event Machine on ODP</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li><a href="../../examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('de/d3c/group__em__queue.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Queues</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaef257858d1fa660524f198dba20fa9eb"><td class="memItemLeft" align="right" valign="top">em_queue_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d3c/group__em__queue.html#gaef257858d1fa660524f198dba20fa9eb">em_queue_create</a> (const char *name, <a class="el" href="../../d4/d11/event__machine__types_8h.html#a47c0f0da93addf232d3d6b720f0bb262">em_queue_type_t</a> type, <a class="el" href="../../d4/d11/event__machine__types_8h.html#a58ebf797967a820c57ced595c2b291e9">em_queue_prio_t</a> prio, em_queue_group_t group, const <a class="el" href="../../d5/d76/structem__queue__conf__t.html">em_queue_conf_t</a> *conf)</td></tr>
<tr class="separator:gaef257858d1fa660524f198dba20fa9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5acbd60ff0d561ca1fa93e627c08dd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d3c/group__em__queue.html#gac5acbd60ff0d561ca1fa93e627c08dd0">em_queue_create_static</a> (const char *name, <a class="el" href="../../d4/d11/event__machine__types_8h.html#a47c0f0da93addf232d3d6b720f0bb262">em_queue_type_t</a> type, <a class="el" href="../../d4/d11/event__machine__types_8h.html#a58ebf797967a820c57ced595c2b291e9">em_queue_prio_t</a> prio, em_queue_group_t group, em_queue_t queue, const <a class="el" href="../../d5/d76/structem__queue__conf__t.html">em_queue_conf_t</a> *conf)</td></tr>
<tr class="separator:gac5acbd60ff0d561ca1fa93e627c08dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a28907b18b348cbb153431c35af5752"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d3c/group__em__queue.html#ga2a28907b18b348cbb153431c35af5752">em_queue_delete</a> (em_queue_t queue)</td></tr>
<tr class="separator:ga2a28907b18b348cbb153431c35af5752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83e001b62c2a87bf862fbf695c5e84fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d3c/group__em__queue.html#ga83e001b62c2a87bf862fbf695c5e84fa">em_queue_set_context</a> (em_queue_t queue, const void *context)</td></tr>
<tr class="separator:ga83e001b62c2a87bf862fbf695c5e84fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65850427f68c8c73e09fbf325190c31c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d3c/group__em__queue.html#ga65850427f68c8c73e09fbf325190c31c">em_queue_get_context</a> (em_queue_t queue)</td></tr>
<tr class="separator:ga65850427f68c8c73e09fbf325190c31c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga973db0375534e9a4a16a7c9a305573bf"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d3c/group__em__queue.html#ga973db0375534e9a4a16a7c9a305573bf">em_queue_get_name</a> (em_queue_t queue, char *name, size_t maxlen)</td></tr>
<tr class="separator:ga973db0375534e9a4a16a7c9a305573bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae54347263c7e083e3af4b1bb4c7df696"><td class="memItemLeft" align="right" valign="top">em_queue_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d3c/group__em__queue.html#gae54347263c7e083e3af4b1bb4c7df696">em_queue_find</a> (const char *name)</td></tr>
<tr class="separator:gae54347263c7e083e3af4b1bb4c7df696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05a93ba11dee6ee28519897d5523831e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d11/event__machine__types_8h.html#a58ebf797967a820c57ced595c2b291e9">em_queue_prio_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d3c/group__em__queue.html#ga05a93ba11dee6ee28519897d5523831e">em_queue_get_priority</a> (em_queue_t queue)</td></tr>
<tr class="separator:ga05a93ba11dee6ee28519897d5523831e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab125a473b889ca79b3d0fab51d27f7b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d11/event__machine__types_8h.html#a47c0f0da93addf232d3d6b720f0bb262">em_queue_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d3c/group__em__queue.html#gab125a473b889ca79b3d0fab51d27f7b9">em_queue_get_type</a> (em_queue_t queue)</td></tr>
<tr class="separator:gab125a473b889ca79b3d0fab51d27f7b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacab36f3033ecd8d67e56433605eb4648"><td class="memItemLeft" align="right" valign="top">em_queue_group_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d3c/group__em__queue.html#gacab36f3033ecd8d67e56433605eb4648">em_queue_get_group</a> (em_queue_t queue)</td></tr>
<tr class="separator:gacab36f3033ecd8d67e56433605eb4648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14a77156789e322f55aafaac039684ee"><td class="memItemLeft" align="right" valign="top">em_event_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d3c/group__em__queue.html#ga14a77156789e322f55aafaac039684ee">em_queue_dequeue</a> (em_queue_t queue)</td></tr>
<tr class="separator:ga14a77156789e322f55aafaac039684ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac77a78d36bb2af6c14b6be215d2bea6a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d3c/group__em__queue.html#gac77a78d36bb2af6c14b6be215d2bea6a">em_queue_dequeue_multi</a> (em_queue_t queue, em_event_t *const events, int num)</td></tr>
<tr class="separator:gac77a78d36bb2af6c14b6be215d2bea6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb697c252066500fffb19390b455c76a"><td class="memItemLeft" align="right" valign="top">em_queue_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d3c/group__em__queue.html#gafb697c252066500fffb19390b455c76a">em_queue_current</a> (void)</td></tr>
<tr class="separator:gafb697c252066500fffb19390b455c76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61d576ae9b5652a697358f1c71d349be"><td class="memItemLeft" align="right" valign="top">em_queue_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d3c/group__em__queue.html#ga61d576ae9b5652a697358f1c71d349be">em_queue_get_first</a> (unsigned int *num)</td></tr>
<tr class="separator:ga61d576ae9b5652a697358f1c71d349be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8578903598bdb715a8bb9b3f552dd1bc"><td class="memItemLeft" align="right" valign="top">em_queue_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d3c/group__em__queue.html#ga8578903598bdb715a8bb9b3f552dd1bc">em_queue_get_next</a> (void)</td></tr>
<tr class="separator:ga8578903598bdb715a8bb9b3f552dd1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Operations on queues</p>
<p>Queues are the communication mechanism used by EM. Each queue is associated with one Execution Object (EO) (or HW functionality), but each EO can have multiple queues.</p>
<p>A queue can have one of six (6) different scheduling modes / queue types:</p>
<ol type="1">
<li>EM_QUEUE_TYPE_ATOMIC<ul>
<li>The atomic queue type limits event scheduling to one event at a time from the queue. The next event from the same queue can only be scheduled after the EO returns from processing the earlier event or calls <a class="el" href="../../dd/d1b/group__em__scheduler.html#gaf80e7173968f134ff3a9df6509c17009">em_atomic_processing_end()</a> to signal end of atomic processing. This type is useful to avoid multicore race conditions as only one core at a time can be working on an event from an atomic queue. Additionally, the ingress-egress event order is maintained.</li>
</ul>
</li>
<li>EM_QUEUE_TYPE_PARALLEL<ul>
<li>Parallel queues have no restriction for scheduling, which means that any amount of events (up to the number of cores in the queue group of the queue) can be processed simultaneously. This provides the best scaling, but race conditions need to be avoided and handled by the application.</li>
</ul>
</li>
<li>EM_QUEUE_TYPE_PARALLEL_ORDERED<ul>
<li><p class="startli">Parallel-Ordered queues have no scheduling restrictions (scheduled like parallel queues i.e. multiple events can be under work concurrently), but events coming from an ordered queue and sent forward will be in original order (as observed at the target queue) even if cores do the processing out of order. Events can be sent to multiple target queues of any queue type and still maintain ordering (the order of events in each target queue, not between different target queues). Note however that if the target queue type is not atomic and the EO can run on more than one thread (set by queue group) then it is possible that the target EO may process the events out of order as it is not limited by atomic scheduling. A chain of ordered (or atomic) queues will still maintain the original order.</p>
<p class="startli">Conceptually an ordering context is atomically created when the scheduler dequeues an event from an ordered queue and represents the sequence number of that event within that queue. The ordering context is valid within the EO receive function and ends implicitly when the EO returns (can be terminated early, see <a class="el" href="../../dd/d1b/group__em__scheduler.html#ga22b178939f69c5d7115e7438f1db0019">em_ordered_processing_end()</a>). Any number of events can be sent under that context and all those will maintain order relative to the current event. The first one sent will take the order position of the current (just received) event. Other events sent during the same ordered context will take consecutive positions (before the next event in the original input queue when it gets scheduled and processed). The original event does not need to be sent forward to maintain order, any event sent will inherit the location of the current ordered context.</p>
<p class="startli">If no event is sent during the EO receive function with ordered context it indicates an implicit skip of that event position in the ordered sequence.</p>
<p class="startli">Atomic queues also maintain ordering, but an ordered queue can increase the performance as multiple cores can concurrently process the events.</p>
</li>
</ul>
</li>
<li>EM_QUEUE_TYPE_UNSCHEDULED<ul>
<li>Unscheduled queues are new to API 1.2. It is a special queue not connected to the scheduler but instead the application needs to dequeue events directly using <a class="el" href="../../de/d3c/group__em__queue.html#ga14a77156789e322f55aafaac039684ee">em_queue_dequeue()</a>. <a class="el" href="../../d5/d33/group__em__event.html#gaca4584a01b71429dfbb045342454b464">em_send()</a> is used to enqueue events to an unscheduled queue, i.e. all queue types look the same to the sender with the exception that <a class="el" href="../../d8/d4c/group__em__event__group.html#gab1ecab5cd71642d3909ffb6a907fd9a5">em_send_group()</a> is not supported for unscheduled queues. Unscheduled queues cannot be added to an EO.</li>
</ul>
</li>
<li>EM_QUEUE_TYPE_LOCAL<ul>
<li><p class="startli">Local queues are special virtual queues bypassing the scheduler for fast core-local pipelining without load balancing or atomic processing. A local queue is connected (added) to an EO in the same way scheduled queues are. Events sent to a local queue are added to a per core (local) storage maintained by the EM dispatcher. This core local event storage is emptied by the dispatcher after the sending EO returns from the receive function. The local events are now immediately dispatched on the current core, i.e. handed to the receive function of the EO that owns the targeted local queue. Only when all local events have been handled is the scheduler allowed to schedule new events for the core. Local queues do not have an explicit ordered or atomic processing context, instead they inherit the context of the EO under which the event was sent (i.e. ordering could still be maintained with careful design). The sending EO's processing context is only released after the local queue is empty, unless the application explicitly ends the context earlier, thus effectively making local processing similar to handling the same function within the sending EO's receive. A local queue is not associated with a queue group and exists on all cores of the EM instance - the application must be able to handle events on all cores (unless sending to the local queue is controlled).</p>
<p class="startli">The local queue concept is a performance optimization and a way to logically split processing into separate EO's but due to the side effects (may delay context release of the sending EO) and limitations should not be used without a valid reason. Local queues are mainly suitable for stateless processing that does not need EM scheduling (no need for ordering or atomic context).</p>
</li>
</ul>
</li>
<li>EM_QUEUE_TYPE_OUTPUT<ul>
<li>An output queue is a system specific implementation of a SW-HW interface. It provides a queue interface for sending events out of EM to a HW device. It could e.g. be used for packet output or towards HW accelerators. The application uses <a class="el" href="../../d5/d33/group__em__event.html#gaca4584a01b71429dfbb045342454b464">em_send()</a> to transmit an event for output. Typically the needed information to bind a queue to an interface is provided via the optional conf-argument given during queue creation (the content of 'conf' is system specific).</li>
</ul>
</li>
</ol>
<p>Currently EM does not define the exact queue behavior except that queues work like FIFOs. This means, e.g. that the maximum length of a queue is system specific (the conf parameter of queue create can be used to provide options)</p>
<p>Special queues towards asynchronous HW functions, e.g. a crypto accelerator, should look like any regular queue from the sender's point of view, i.e. <a class="el" href="../../d5/d33/group__em__event.html#gaca4584a01b71429dfbb045342454b464">em_send()</a> and related functions work. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaef257858d1fa660524f198dba20fa9eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">em_queue_t em_queue_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d11/event__machine__types_8h.html#a47c0f0da93addf232d3d6b720f0bb262">em_queue_type_t</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d11/event__machine__types_8h.html#a58ebf797967a820c57ced595c2b291e9">em_queue_prio_t</a>&#160;</td>
          <td class="paramname"><em>prio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">em_queue_group_t&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/d76/structem__queue__conf__t.html">em_queue_conf_t</a> *&#160;</td>
          <td class="paramname"><em>conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new queue with a dynamic queue handle (i.e. handle given by EM)</p>
<p>The given name string is copied into an EM internal data structure. The maximum string length is EM_QUEUE_NAME_LEN.</p>
<p>Create scheduled atomic, parallel or parallel-ordered queues by using the types EM_QUEUE_TYPE_ATOMIC, EM_QUEUE_TYPE_PARALLEL or EM_QUEUE_TYPE_PARALLEL_ORDERED, respectively.</p>
<p>To create an unscheduled queue, use the type EM_QUEUE_TYPE_UNSCHEDULED. The prio and queue group are not relevant, but need to be set to EM_QUEUE_PRIO_UNDEF and EM_QUEUE_GROUP_UNDEF. Unscheduled queues can't be associated with an EO (<a class="el" href="../../d8/d5f/group__em__eo.html#ga9b00e0cf2fcef155ea26e809cac3be0e">em_eo_add_queue()</a> fails).</p>
<p>To create a local queue, use type EM_QUEUE_TYPE_LOCAL. The queue group is not relevant and must be set to EM_QUEUE_GROUP_UNDEF. The virtual local queue is created for all cores in this EM instance. Note also that the implementation may not implement priorities for local queues.</p>
<p>To create an output queue, use the type EM_QUEUE_TYPE_OUTPUT. Pass the needed information to bind a queue with an interface via the conf-argument (content is system and output-type specific). The queue group is not relevant and must be set to EM_QUEUE_GROUP_UNDEF. Note also that the implementation may not implement priorities for output queues.</p>
<p>The 'conf' argument is optional and can be used to pass extra attributes (e.g. require non-blocking behaviour, if supported) to the system specific implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Queue name (optional, NULL ok) </td></tr>
    <tr><td class="paramname">type</td><td>Queue type </td></tr>
    <tr><td class="paramname">prio</td><td>Queue priority class </td></tr>
    <tr><td class="paramname">group</td><td>Queue group for this queue </td></tr>
    <tr><td class="paramname">conf</td><td>Optional configuration data, NULL for defaults</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New queue handle or EM_QUEUE_UNDEF on an error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d01/group__em__queue__group.html#gadbdbc7cadcd97ceae5682710965e16fd">em_queue_group_create()</a>, <a class="el" href="../../de/d3c/group__em__queue.html#ga2a28907b18b348cbb153431c35af5752">em_queue_delete()</a>, <a class="el" href="../../d5/d76/structem__queue__conf__t.html">em_queue_conf_t</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../dd/d24/atomic_processing_end_8c-example.html#a15">atomic_processing_end.c</a>, <a class="el" href="../../d9/d6a/dispatcher_callback_8c-example.html#a30">dispatcher_callback.c</a>, <a class="el" href="../../d9/d32/error_8c-example.html#a13">error.c</a>, <a class="el" href="../../d5/d77/event_group_8c-example.html#a14">event_group.c</a>, <a class="el" href="../../d0/dba/event_group_abort_8c-example.html#a30">event_group_abort.c</a>, <a class="el" href="../../da/daa/event_group_assign_end_8c-example.html#a13">event_group_assign_end.c</a>, <a class="el" href="../../d4/d81/event_group_chaining_8c-example.html#a14">event_group_chaining.c</a>, <a class="el" href="../../d1/d25/fractal_8c-example.html#a36">fractal.c</a>, <a class="el" href="../../d5/dfc/hello_8c-example.html#a23">hello.c</a>, <a class="el" href="../../d4/d14/ordered_8c-example.html#a12">ordered.c</a>, <a class="el" href="../../d7/dbc/pairs_8c-example.html#a10">pairs.c</a>, <a class="el" href="../../d8/dc3/queue_group_8c-example.html#a18">queue_group.c</a>, <a class="el" href="../../d6/dd3/queue_groups_8c-example.html#a17">queue_groups.c</a>, <a class="el" href="../../df/da9/queue_types_ag_8c-example.html#a29">queue_types_ag.c</a>, <a class="el" href="../../db/dcf/queue_types_local_8c-example.html#a23">queue_types_local.c</a>, <a class="el" href="../../d6/d76/queues_8c-example.html#a33">queues.c</a>, <a class="el" href="../../d0/d69/queues_local_8c-example.html#a35">queues_local.c</a>, <a class="el" href="../../d1/ddd/queues_unscheduled_8c-example.html#a42">queues_unscheduled.c</a>, <a class="el" href="../../de/daa/send_multi_8c-example.html#a43">send_multi.c</a>, <a class="el" href="../../d5/dfe/timer_hello_8c-example.html#a18">timer_hello.c</a>, and <a class="el" href="../../dd/d10/timer_test_8c-example.html#a15">timer_test.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="../../dd/dba/event__machine__queue_8c_source.html#l00041">41</a> of file <a class="el" href="../../dd/dba/event__machine__queue_8c_source.html">event_machine_queue.c</a>.</p>

</div>
</div>
<a class="anchor" id="gac5acbd60ff0d561ca1fa93e627c08dd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a> em_queue_create_static </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d11/event__machine__types_8h.html#a47c0f0da93addf232d3d6b720f0bb262">em_queue_type_t</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d11/event__machine__types_8h.html#a58ebf797967a820c57ced595c2b291e9">em_queue_prio_t</a>&#160;</td>
          <td class="paramname"><em>prio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">em_queue_group_t&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">em_queue_t&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/d76/structem__queue__conf__t.html">em_queue_conf_t</a> *&#160;</td>
          <td class="paramname"><em>conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new queue with a static queue hande (i.e. given by the user).</p>
<p>Note, that the system may have a limited amount of static handles available, so prefer the use of dynamic queues, unless static handles are really needed. The range of static identifiers/handles is system dependent, but macros EM_QUEUE_STATIC_MIN and EM_QUEUE_STATIC_MAX can be used to abstract actual values, e.g. use EM_QUEUE_STATIC_MIN+x for the application.</p>
<p>Otherwise like <a class="el" href="../../de/d3c/group__em__queue.html#gaef257858d1fa660524f198dba20fa9eb">em_queue_create()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Queue name (optional, NULL ok) </td></tr>
    <tr><td class="paramname">type</td><td>Queue scheduling type </td></tr>
    <tr><td class="paramname">prio</td><td>Queue priority </td></tr>
    <tr><td class="paramname">group</td><td>Queue group for this queue </td></tr>
    <tr><td class="paramname">queue</td><td>Requested queue handle from the static range </td></tr>
    <tr><td class="paramname">conf</td><td>Optional configuration data, NULL for defaults</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EM_OK if successful.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/d3c/group__em__queue.html#gaef257858d1fa660524f198dba20fa9eb">em_queue_create()</a> </dd></dl>

<p>Definition at line <a class="el" href="../../dd/dba/event__machine__queue_8c_source.html#l00058">58</a> of file <a class="el" href="../../dd/dba/event__machine__queue_8c_source.html">event_machine_queue.c</a>.</p>

</div>
</div>
<a class="anchor" id="gafb697c252066500fffb19390b455c76a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">em_queue_t em_queue_current </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current active queue</p>
<p>The 'current active queue' is the queue that delivered the input event to the EO-receive that is currently being run.</p>
<p>Only valid if called within an EO-receive context, will return EM_QUEUE_UNDEF otherwise, i.e. can be called from the EO-receive functions or subfunctions thereof. Note that calling <a class="el" href="../../de/d3c/group__em__queue.html#gafb697c252066500fffb19390b455c76a">em_queue_current()</a> from an EO-start/stop function that was launched from within an EO's receive function will return EM_QUEUE_UNDEF.</p>
<dl class="section return"><dt>Returns</dt><dd>The current queue or EM_QUEUE_UNDEF if no current queue (or error) </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../df/da9/queue_types_ag_8c-example.html#a42">queue_types_ag.c</a>, and <a class="el" href="../../db/dcf/queue_types_local_8c-example.html#a19">queue_types_local.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="../../dd/dba/event__machine__queue_8c_source.html#l00301">301</a> of file <a class="el" href="../../dd/dba/event__machine__queue_8c_source.html">event_machine_queue.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga2a28907b18b348cbb153431c35af5752"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a> em_queue_delete </td>
          <td>(</td>
          <td class="paramtype">em_queue_t&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete a queue.</p>
<p>Unallocates the queue handle. This is an immediate deletion and can only be done after the queue has been removed from scheduling using <a class="el" href="../../d8/d5f/group__em__eo.html#ga6c47c33e158c209480d485a1b8d4e72f">em_eo_remove_queue()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Queue handle to delete</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EM_OK if successful.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d8/d5f/group__em__eo.html#ga6c47c33e158c209480d485a1b8d4e72f">em_eo_remove_queue()</a>, <a class="el" href="../../de/d3c/group__em__queue.html#gaef257858d1fa660524f198dba20fa9eb">em_queue_create()</a>, <a class="el" href="../../de/d3c/group__em__queue.html#gac5acbd60ff0d561ca1fa93e627c08dd0">em_queue_create_static()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../d9/d6a/dispatcher_callback_8c-example.html#a44">dispatcher_callback.c</a>, <a class="el" href="../../d5/dfc/hello_8c-example.html#a38">hello.c</a>, <a class="el" href="../../d8/dc3/queue_group_8c-example.html#a57">queue_group.c</a>, <a class="el" href="../../d6/dd3/queue_groups_8c-example.html#a58">queue_groups.c</a>, <a class="el" href="../../d1/ddd/queues_unscheduled_8c-example.html#a24">queues_unscheduled.c</a>, and <a class="el" href="../../de/daa/send_multi_8c-example.html#a24">send_multi.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="../../dd/dba/event__machine__queue_8c_source.html#l00087">87</a> of file <a class="el" href="../../dd/dba/event__machine__queue_8c_source.html">event_machine_queue.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga14a77156789e322f55aafaac039684ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">em_event_t em_queue_dequeue </td>
          <td>(</td>
          <td class="paramtype">em_queue_t&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dequeue an event from an unscheduled queue</p>
<p>This can only be used with unscheduled queues created with the type EM_QUEUE_TYPE_UNSCHEDULED. Events are added to these queues with <a class="el" href="../../d5/d33/group__em__event.html#gaca4584a01b71429dfbb045342454b464">em_send()</a>, similar to queues of other types, but applications needs to explicitly dequeue the event(s). Unscheduled queues are general purpose FIFOs, i.e. send(enqueue) to tail and dequeue from head. The maximum length of an unscheduled queue is system specific.</p>
<p>An unscheduled queue can also have a context, but if used it needs to be asked separately using <a class="el" href="../../de/d3c/group__em__queue.html#ga65850427f68c8c73e09fbf325190c31c">em_queue_get_context()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Unscheduled queue handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Event from head of queue or EM_EVENT_UNDEF if there was no events or an error occurred. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../d1/ddd/queues_unscheduled_8c-example.html#a21">queues_unscheduled.c</a>, and <a class="el" href="../../de/daa/send_multi_8c-example.html#a21">send_multi.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="../../dd/dba/event__machine__queue_8c_source.html#l00229">229</a> of file <a class="el" href="../../dd/dba/event__machine__queue_8c_source.html">event_machine_queue.c</a>.</p>

</div>
</div>
<a class="anchor" id="gac77a78d36bb2af6c14b6be215d2bea6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int em_queue_dequeue_multi </td>
          <td>(</td>
          <td class="paramtype">em_queue_t&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">em_event_t *const&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dequeue multiple events from an unscheduled queue</p>
<p>This can only be used with unscheduled queues created with the type EM_QUEUE_TYPE_UNSCHEDULED. Events are added to these queues with <a class="el" href="../../d5/d33/group__em__event.html#gaca4584a01b71429dfbb045342454b464">em_send()</a>, similar to queues of other types, but applications needs to explicitly dequeue the event(s). Unscheduled queues are general purpose FIFOs, i.e. send(enqueue) to tail and dequeue from head. The maximum length of an unscheduled queue is system specific.</p>
<p>An unscheduled queue can also have a context, but needs to be asked separately using <a class="el" href="../../de/d3c/group__em__queue.html#ga65850427f68c8c73e09fbf325190c31c">em_queue_get_context()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">queue</td><td>Unscheduled queue handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">events</td><td>Array of event handles for output </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">num</td><td>Maximum number of events to dequeue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of successfully dequeued events (0 to num) </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../de/daa/send_multi_8c-example.html#a35">send_multi.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="../../dd/dba/event__machine__queue_8c_source.html#l00259">259</a> of file <a class="el" href="../../dd/dba/event__machine__queue_8c_source.html">event_machine_queue.c</a>.</p>

</div>
</div>
<a class="anchor" id="gae54347263c7e083e3af4b1bb4c7df696"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">em_queue_t em_queue_find </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a queue by name.</p>
<p>Finds a queue by the given name (exact match). An empty string will not match anything. The search is case sensitive. The function will return the first match only if there are duplicate names, Be aware of that the search may take a long time if there are many queues.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name to look for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>queue handle or EM_QUEUE_UNDEF if not found</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/d3c/group__em__queue.html#gaef257858d1fa660524f198dba20fa9eb">em_queue_create()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../df/da9/queue_types_ag_8c-example.html#a74">queue_types_ag.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="../../dd/dba/event__machine__queue_8c_source.html#l00167">167</a> of file <a class="el" href="../../dd/dba/event__machine__queue_8c_source.html">event_machine_queue.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga65850427f68c8c73e09fbf325190c31c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* em_queue_get_context </td>
          <td>(</td>
          <td class="paramtype">em_queue_t&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get queue specific (application) context.</p>
<p>Returns the value application has earlier set with <a class="el" href="../../de/d3c/group__em__queue.html#ga83e001b62c2a87bf862fbf695c5e84fa">em_queue_set_context()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Queue for which the context is requested</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Queue specific context pointer or NULL on error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/d3c/group__em__queue.html#ga83e001b62c2a87bf862fbf695c5e84fa">em_queue_set_context()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../db/dcf/queue_types_local_8c-example.html#a51">queue_types_local.c</a>, <a class="el" href="../../d1/ddd/queues_unscheduled_8c-example.html#a49">queues_unscheduled.c</a>, and <a class="el" href="../../de/daa/send_multi_8c-example.html#a50">send_multi.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="../../dd/dba/event__machine__queue_8c_source.html#l00119">119</a> of file <a class="el" href="../../dd/dba/event__machine__queue_8c_source.html">event_machine_queue.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga61d576ae9b5652a697358f1c71d349be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">em_queue_t em_queue_get_first </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize queue iteration and return the first queue handle.</p>
<p>Can be used to initialize the iteration to retrieve all created queues for debugging or management purposes. Use <a class="el" href="../../de/d3c/group__em__queue.html#ga8578903598bdb715a8bb9b3f552dd1bc">em_queue_get_next()</a> after this call until it returns EM_QUEUE_UNDEF. A new call to <a class="el" href="../../de/d3c/group__em__queue.html#ga61d576ae9b5652a697358f1c71d349be">em_queue_get_first()</a> resets the iteration, which is maintained per core (thread). The operation should be completed in one go before returning from the EO's event receive function (or start/stop).</p>
<p>The number of queues (output arg 'num') may not match the amount of queues actually returned by iterating using <a class="el" href="../../de/d3c/group__em__queue.html#ga8578903598bdb715a8bb9b3f552dd1bc">em_queue_get_next()</a> if queues are added or removed in parallel by another core. The order of the returned queue handles is undefined.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;unsigned int num;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;em_queue_t q = em_queue_get_first(&amp;num);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;while (q != EM_QUEUE_UNDEF) {</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;   q = em_queue_get_next();</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;}</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>[out] Pointer to an unsigned int to store the amount of queues into</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first queue handle or EM_QUEUE_UNDEF if none exist</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/d3c/group__em__queue.html#ga8578903598bdb715a8bb9b3f552dd1bc">em_queue_get_next()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../df/da9/queue_types_ag_8c-example.html#a68">queue_types_ag.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="../../dd/dba/event__machine__queue_8c_source.html#l00312">312</a> of file <a class="el" href="../../dd/dba/event__machine__queue_8c_source.html">event_machine_queue.c</a>.</p>

</div>
</div>
<a class="anchor" id="gacab36f3033ecd8d67e56433605eb4648"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">em_queue_group_t em_queue_get_group </td>
          <td>(</td>
          <td class="paramtype">em_queue_t&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the queue's queue group</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Queue handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Queue group or EM_QUEUE_GROUP_UNDEF on error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/d3c/group__em__queue.html#gaef257858d1fa660524f198dba20fa9eb">em_queue_create()</a>, <a class="el" href="../../d9/d01/group__em__queue__group.html#gadbdbc7cadcd97ceae5682710965e16fd">em_queue_group_create()</a>, <a class="el" href="../../d9/d01/group__em__queue__group.html#gad219e4c4e8de4be8b4299dbdccacfcb5">em_queue_group_modify()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../d8/dc3/queue_group_8c-example.html#a44">queue_group.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="../../dd/dba/event__machine__queue_8c_source.html#l00212">212</a> of file <a class="el" href="../../dd/dba/event__machine__queue_8c_source.html">event_machine_queue.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga973db0375534e9a4a16a7c9a305573bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t em_queue_get_name </td>
          <td>(</td>
          <td class="paramtype">em_queue_t&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the queue name.</p>
<p>Returns the name given to a queue when it was created. A copy of the queue name string (up to 'maxlen' characters) is written to the user given buffer. The string is always null terminated even if the given buffer length is less than the name length.</p>
<p>The function returns '0' and writes an empty string if the queue has no name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Queue handle </td></tr>
    <tr><td class="paramname">name</td><td>Destination buffer </td></tr>
    <tr><td class="paramname">maxlen</td><td>Maximum length (including the terminating '0')</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of characters written (excludes the terminating '0').</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/d3c/group__em__queue.html#gaef257858d1fa660524f198dba20fa9eb">em_queue_create()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../dd/d24/atomic_processing_end_8c-example.html#a38">atomic_processing_end.c</a>, and <a class="el" href="../../df/da9/queue_types_ag_8c-example.html#a69">queue_types_ag.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="../../dd/dba/event__machine__queue_8c_source.html#l00133">133</a> of file <a class="el" href="../../dd/dba/event__machine__queue_8c_source.html">event_machine_queue.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga8578903598bdb715a8bb9b3f552dd1bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">em_queue_t em_queue_get_next </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the next queue handle.</p>
<p>Continues the queue iteration started by <a class="el" href="../../de/d3c/group__em__queue.html#ga61d576ae9b5652a697358f1c71d349be">em_queue_get_first()</a> and returns the next queue handle.</p>
<dl class="section return"><dt>Returns</dt><dd>The next queue handle or EM_QUEUE_UNDEF if the queue iteration is completed (i.e. no more queues available).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/d3c/group__em__queue.html#ga61d576ae9b5652a697358f1c71d349be">em_queue_get_first()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../df/da9/queue_types_ag_8c-example.html#a75">queue_types_ag.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="../../dd/dba/event__machine__queue_8c_source.html#l00338">338</a> of file <a class="el" href="../../dd/dba/event__machine__queue_8c_source.html">event_machine_queue.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga05a93ba11dee6ee28519897d5523831e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d11/event__machine__types_8h.html#a58ebf797967a820c57ced595c2b291e9">em_queue_prio_t</a> em_queue_get_priority </td>
          <td>(</td>
          <td class="paramtype">em_queue_t&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the queue priority.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Queue handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Priority class or EM_QUEUE_PRIO_UNDEF on an error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/d3c/group__em__queue.html#gaef257858d1fa660524f198dba20fa9eb">em_queue_create()</a> </dd></dl>

<p>Definition at line <a class="el" href="../../dd/dba/event__machine__queue_8c_source.html#l00184">184</a> of file <a class="el" href="../../dd/dba/event__machine__queue_8c_source.html">event_machine_queue.c</a>.</p>

</div>
</div>
<a class="anchor" id="gab125a473b889ca79b3d0fab51d27f7b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d11/event__machine__types_8h.html#a47c0f0da93addf232d3d6b720f0bb262">em_queue_type_t</a> em_queue_get_type </td>
          <td>(</td>
          <td class="paramtype">em_queue_t&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the queue type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Queue handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Queue type or EM_QUEUE_TYPE_UNDEF on an error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/d3c/group__em__queue.html#gaef257858d1fa660524f198dba20fa9eb">em_queue_create()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../df/da9/queue_types_ag_8c-example.html#a50">queue_types_ag.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="../../dd/dba/event__machine__queue_8c_source.html#l00198">198</a> of file <a class="el" href="../../dd/dba/event__machine__queue_8c_source.html">event_machine_queue.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga83e001b62c2a87bf862fbf695c5e84fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a> em_queue_set_context </td>
          <td>(</td>
          <td class="paramtype">em_queue_t&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set queue specific (application) context.</p>
<p>This is a single pointer associated with a queue. The application can use it to access some context data quickly (without a lookup). The context is given as an argument to the EO receive function. EM does not dereference it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Queue to which associate the context </td></tr>
    <tr><td class="paramname">context</td><td>Context pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EM_OK if successful.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d8/d5f/group__em__eo.html#ga63161b6f46fb08a1708bad6c1fde2622">em_receive_func_t()</a>, <a class="el" href="../../de/d3c/group__em__queue.html#ga65850427f68c8c73e09fbf325190c31c">em_queue_get_context()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../d9/d6a/dispatcher_callback_8c-example.html#a35">dispatcher_callback.c</a>, <a class="el" href="../../d1/d25/fractal_8c-example.html#a52">fractal.c</a>, <a class="el" href="../../d5/dfc/hello_8c-example.html#a28">hello.c</a>, <a class="el" href="../../d4/d14/ordered_8c-example.html#a15">ordered.c</a>, <a class="el" href="../../d8/dc3/queue_group_8c-example.html#a54">queue_group.c</a>, <a class="el" href="../../d6/dd3/queue_groups_8c-example.html#a56">queue_groups.c</a>, <a class="el" href="../../df/da9/queue_types_ag_8c-example.html#a28">queue_types_ag.c</a>, <a class="el" href="../../db/dcf/queue_types_local_8c-example.html#a29">queue_types_local.c</a>, <a class="el" href="../../d6/d76/queues_8c-example.html#a35">queues.c</a>, <a class="el" href="../../d0/d69/queues_local_8c-example.html#a36">queues_local.c</a>, <a class="el" href="../../d1/ddd/queues_unscheduled_8c-example.html#a44">queues_unscheduled.c</a>, and <a class="el" href="../../de/daa/send_multi_8c-example.html#a48">send_multi.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="../../dd/dba/event__machine__queue_8c_source.html#l00105">105</a> of file <a class="el" href="../../dd/dba/event__machine__queue_8c_source.html">event_machine_queue.c</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
  <div id="footer" class="tabs">
   <div class="headertitle"> 
     &copy; 2017 Nokia Networks
   </div>
  </div>
 </body>
</html>
